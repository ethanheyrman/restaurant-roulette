{"ast":null,"code":"import { getIn } from 'final-form'; //      \n\n/**\n * Predicate to identify inputs that can have focus() called on them\n */\n\nvar isFocusableInput = function isFocusableInput(wtf) {\n  return !!(wtf && typeof wtf.focus === 'function');\n}; //      \n\n/**\n * Gets all the inputs inside all forms on the page\n */\n\n\nvar getAllInputs = function getAllInputs() {\n  if (typeof document === 'undefined') {\n    return [];\n  }\n\n  return Array.prototype.slice.call(document.forms).reduce(function (accumulator, form) {\n    return accumulator.concat(Array.prototype.slice.call(form).filter(isFocusableInput));\n  }, []);\n}; //      \n\n/**\n * Finds the input by looking if the name attribute path is existing in the errors object\n */\n\n\nvar findInput = function findInput(inputs, errors) {\n  return inputs.find(function (input) {\n    return input.name && getIn(errors, input.name);\n  });\n}; //      \n\n\nvar noop = function noop() {};\n\nvar createDecorator = function createDecorator(getInputs, findInput$$1) {\n  return function (form) {\n    var focusOnFirstError = function focusOnFirstError(errors) {\n      if (!getInputs) {\n        getInputs = getAllInputs;\n      }\n\n      if (!findInput$$1) {\n        findInput$$1 = findInput;\n      }\n\n      var firstInput = findInput$$1(getInputs(), errors);\n\n      if (firstInput) {\n        firstInput.focus();\n      }\n    }; // Save original submit function\n\n\n    var originalSubmit = form.submit; // Subscribe to errors, and keep a local copy of them\n\n    var state = {};\n    var unsubscribe = form.subscribe(function (nextState) {\n      state = nextState;\n    }, {\n      errors: true,\n      submitErrors: true\n    }); // What to do after submit\n\n    var afterSubmit = function afterSubmit() {\n      var _state = state,\n          errors = _state.errors,\n          submitErrors = _state.submitErrors;\n\n      if (errors && Object.keys(errors).length) {\n        focusOnFirstError(errors);\n      } else if (submitErrors && Object.keys(submitErrors).length) {\n        focusOnFirstError(submitErrors);\n      }\n    }; // Rewrite submit function\n\n\n    form.submit = function () {\n      var result = originalSubmit.call(form);\n\n      if (result && typeof result.then === 'function') {\n        // async\n        result.then(afterSubmit, noop);\n      } else {\n        // sync\n        afterSubmit();\n      }\n\n      return result;\n    };\n\n    return function () {\n      unsubscribe();\n      form.submit = originalSubmit;\n    };\n  };\n}; //      \n\n/**\n * Generates a function to get all the inputs in a form with the specified name\n */\n\n\nvar getFormInputs = function getFormInputs(name) {\n  return function () {\n    if (typeof document === 'undefined') {\n      return [];\n    } // $FlowFixMe\n\n\n    var form = document.forms[name];\n    return form && form.length ? Array.prototype.slice.call(form).filter(isFocusableInput) : []; // cast cheat to get from HTMLFormElement children to FocusableInput\n  };\n}; //\n\n\nexport default createDecorator;\nexport { getFormInputs };","map":{"version":3,"sources":["/Users/niharikatomar/Desktop/rr/restaurant-roulette/frontend/node_modules/final-form-focus/dist/final-form-focus.es.js"],"names":["getIn","isFocusableInput","wtf","focus","getAllInputs","document","Array","prototype","slice","call","forms","reduce","accumulator","form","concat","filter","findInput","inputs","errors","find","input","name","noop","createDecorator","getInputs","findInput$$1","focusOnFirstError","firstInput","originalSubmit","submit","state","unsubscribe","subscribe","nextState","submitErrors","afterSubmit","_state","Object","keys","length","result","then","getFormInputs"],"mappings":"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","sourcesContent":["import { getIn } from 'final-form';\n\n//      \n\n/**\n * Predicate to identify inputs that can have focus() called on them\n */\nvar isFocusableInput = function isFocusableInput(wtf) {\n  return !!(wtf && typeof wtf.focus === 'function');\n};\n\n//      \n/**\n * Gets all the inputs inside all forms on the page\n */\n\nvar getAllInputs = function getAllInputs() {\n  if (typeof document === 'undefined') {\n    return [];\n  }\n\n  return Array.prototype.slice.call(document.forms).reduce(function (accumulator, form) {\n    return accumulator.concat(Array.prototype.slice.call(form).filter(isFocusableInput));\n  }, []);\n};\n\n//      \n/**\n * Finds the input by looking if the name attribute path is existing in the errors object\n */\n\nvar findInput = function findInput(inputs, errors) {\n  return inputs.find(function (input) {\n    return input.name && getIn(errors, input.name);\n  });\n};\n\n//      \n\nvar noop = function noop() {};\n\nvar createDecorator = function createDecorator(getInputs, findInput$$1) {\n  return function (form) {\n    var focusOnFirstError = function focusOnFirstError(errors) {\n      if (!getInputs) {\n        getInputs = getAllInputs;\n      }\n\n      if (!findInput$$1) {\n        findInput$$1 = findInput;\n      }\n\n      var firstInput = findInput$$1(getInputs(), errors);\n\n      if (firstInput) {\n        firstInput.focus();\n      }\n    }; // Save original submit function\n\n\n    var originalSubmit = form.submit; // Subscribe to errors, and keep a local copy of them\n\n    var state = {};\n    var unsubscribe = form.subscribe(function (nextState) {\n      state = nextState;\n    }, {\n      errors: true,\n      submitErrors: true\n    }); // What to do after submit\n\n    var afterSubmit = function afterSubmit() {\n      var _state = state,\n          errors = _state.errors,\n          submitErrors = _state.submitErrors;\n\n      if (errors && Object.keys(errors).length) {\n        focusOnFirstError(errors);\n      } else if (submitErrors && Object.keys(submitErrors).length) {\n        focusOnFirstError(submitErrors);\n      }\n    }; // Rewrite submit function\n\n\n    form.submit = function () {\n      var result = originalSubmit.call(form);\n\n      if (result && typeof result.then === 'function') {\n        // async\n        result.then(afterSubmit, noop);\n      } else {\n        // sync\n        afterSubmit();\n      }\n\n      return result;\n    };\n\n    return function () {\n      unsubscribe();\n      form.submit = originalSubmit;\n    };\n  };\n};\n\n//      \n/**\n * Generates a function to get all the inputs in a form with the specified name\n */\n\nvar getFormInputs = function getFormInputs(name) {\n  return function () {\n    if (typeof document === 'undefined') {\n      return [];\n    } // $FlowFixMe\n\n\n    var form = document.forms[name];\n    return form && form.length ? Array.prototype.slice.call(form).filter(isFocusableInput) : []; // cast cheat to get from HTMLFormElement children to FocusableInput\n  };\n};\n\n//\n\nexport default createDecorator;\nexport { getFormInputs };\n"]},"metadata":{},"sourceType":"module"}